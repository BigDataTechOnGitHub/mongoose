import groovy.json.JsonSlurper
import groovy.json.JsonParserType

import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import java.util.stream.Collectors

description = "Mongoose is a high-load storage performance testing tool"

buildscript {
	dependencies {
		classpath "com.google.gradle:osdetector-gradle-plugin:1.4.0"
	}
	repositories {
		mavenCentral()
	}
}

allprojects {

	repositories {
		mavenCentral()
	}

	apply plugin: "java"
	apply plugin: "maven"
	apply plugin: "signing"

	group = "com.github.emc-mongoose"
	version = defineVersion()

	signing {
		required {
			gradle.taskGraph.hasTask("uploadArchives")
		}
		sign configurations.archives
	}

	// travis deploy stage runs "./gradlew check" again which is unnecessary
	check.dependsOn -= test
}

String defineVersion() {
	def configFilePath = [
			rootDir, "src", "main", "resources", "install", "config", "defaults.json",
		]
		.join(File.separator);
	def inputFile = new File(configFilePath)
	def json = new JsonSlurper().setType(JsonParserType.LAX).parseText(inputFile.text)
	json.version
}

task printVersion {
	group = "versioning"
	description = "Prints Mongoose version."
	doLast { logger.quiet "Mongoose version: $version" }
}

ext {

	depVersion = [
		confuse: "1.0.7",
		confuseIoJson: "1.0.2",
		commonsCodec : "1.11",
		commonsLang : "2.6",
		disruptor : "3.4.2",
		fiber4j: "[1.0.0,)",
		jackson : "2.9.5",
		javaCommons : "[2.0.9,)",
		javassist : "3.22.0-GA",
		junit : "4.12",
		slf4j : "1.7.25",
		log4j : "2.8.2",
		metrics : "4.0.2",
		nagaina : "[3.6.10,)",
		netty : "4.1.25.Final",
		nettyConnectionPool : "[1.0.1,)",
	]

	leafProjects = subprojects.findAll {
		it != project("scenario") &&
			it != project("scenario:step") &&
			it != project("scenario:step:type") &&
			it != project("storage") &&
			it != project("storage:driver") &&
			it != project("storage:driver:coop") &&
			it != project("storage:driver:nio") &&
			it != project("storage:driver:preempt")
	}

	log4j2PluginsDatPath = Paths.get(
		"META-INF", "org", "apache", "logging", "log4j", "core", "config", "plugins",
		"Log4j2Plugins.dat",
	)
}

dependencies {

	compile(
		"commons-codec:commons-codec:${depVersion.commonsCodec}",
		"commons-lang:commons-lang:${depVersion.commonsLang}",
		"com.fasterxml.jackson.core:jackson-annotations:${depVersion.jackson}",
		"com.fasterxml.jackson.core:jackson-core:${depVersion.jackson}",
		"com.fasterxml.jackson.core:jackson-databind:${depVersion.jackson}",
		"com.github.akurilov:confuse:${depVersion.confuse}",
		"com.github.akurilov:confuse-io-json:${depVersion.confuseIoJson}",
		"com.github.akurilov:fiber4j:${depVersion.fiber4j}",
		"com.github.akurilov:java-commons:${depVersion.javaCommons}",
		"com.github.akurilov:netty-connection-pool:${depVersion.nettyConnectionPool}",
		"com.lmax:disruptor:${depVersion.disruptor}",
		"io.dropwizard.metrics:metrics-core:${depVersion.metrics}",
		"io.netty:netty-buffer:${depVersion.netty}",
		"io.netty:netty-codec-http:${depVersion.netty}",
		"io.netty:netty-common:${depVersion.netty}",
		"io.netty:netty-handler:${depVersion.netty}",
		"io.netty:netty-transport:${depVersion.netty}",
		"org.apache.logging.log4j:log4j-api:${depVersion.log4j}",
		"org.apache.logging.log4j:log4j-core:${depVersion.log4j}",
	)

	runtime(
		"io.netty:netty-transport-native-epoll:${depVersion.netty}:linux-x86_64",
		"io.netty:netty-transport-native-kqueue:${depVersion.netty}:osx-x86_64",
		"org.apache.logging.log4j:log4j-jul:${depVersion.log4j}",
		"org.apache.logging.log4j:log4j-slf4j-impl:${depVersion.log4j}",
		"org.javassist:javassist:${depVersion.javassist}",
		"org.slf4j:slf4j-api:${depVersion.slf4j}",
	)

	testCompile(
		"com.github.fge:json-schema-validator:2.2.6",
		"junit:junit:${depVersion.junit}",
	)
}


def classPathString(final configuration, final isExt) {
	return configuration
		.collect {
			file ->
				if(isExt) {
					// it's 3rd party if jar file name doesn't contain the root project name
					if(-1 == file.name.indexOf(rootProject.name)) {
						["..", "lib", file.name].join(File.separator)
					} else {
						["..", file.name].join(File.separator)
					}
				} else {
					// it's 3rd party if jar file name doesn't contain the root project name
					if(-1 == file.name.indexOf(rootProject.name)) {
						["lib", file.name].join(File.separator)
					} else {
						file.name
					}
				}
		}
		.join(" ")
}

void collectName(Project p, LinkedList<String> names) {
	names.addFirst p.name
	if(p.parent != null) {
		collectName(p.parent, names)
	}
}

subprojects {

	afterEvaluate {

		compileJava {
			sourceCompatibility = JavaVersion.VERSION_1_8
			targetCompatibility = JavaVersion.VERSION_1_8
		}

		compileTestJava {
			sourceCompatibility = JavaVersion.VERSION_1_8
			targetCompatibility = JavaVersion.VERSION_1_8
		}
	}
}

task wrapper(type: Wrapper) {
	gradleVersion = "4.7"
}

static def isTestsProject(final Project p) {
	if(p == null) {
		return false
	} else if(p.name.contains("test")) {
		return true
	} else {
		return isTestsProject(p.parent)
	}
}

task mergeLog4j2PluginsDat(dependsOn: compileJava) {
	doLast {

		byte[] pluginsData
		byte[] customPluginsData

		configurations.runtime
			.each {
				if(!it.isDirectory()) {
					zipTree(it)
						.filter {
							it.toString().endsWith(log4j2PluginsDatPath.toString())
						}
						.each {
							pluginsData = Files.readAllBytes(Paths.get(it.toString()))
						}
				}
			}

		sourceSets.main.output.classesDirs
			.any {
				customPluginsData = Files.readAllBytes(
					Paths.get(it.toString(), log4j2PluginsDatPath.toString(),)
				)
			}

		sourceSets.main.output.classesDirs
			.any {
				Files.write(
					Paths.get(it.toString(), log4j2PluginsDatPath.toString(),),
					pluginsData, StandardOpenOption.TRUNCATE_EXISTING
				)
				Files.write(
					Paths.get(it.toString(), log4j2PluginsDatPath.toString(),),
					customPluginsData, StandardOpenOption.APPEND
				)
			}
	}
}

task mainJar(type: Jar, dependsOn: [compileJava, mergeLog4j2PluginsDat]) {

	baseName = rootProject.name
	version = version
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	manifest {
		attributes(
			"Implementation-Version": version,
			"Implementation-Title": rootProject.name,
			"Main-Class": "com.emc.mongoose.Main",
		)
	}

	from compileJava.outputs.files

	from sourceSets.main.resources

	from configurations.runtime.collect {
		it.isDirectory() ? it : zipTree(it)
	}

	exclude "META-INF/*.RSA", "META-INF/*.SF", "META-INF/*.DSA"

	leafProjects
		.each {
			final Project p = it
			from(p.jar.outputs.files) {
				into "install${File.separator}ext"
				rename {
					fileName -> "${p.description}.jar"
				}
			}
		}
}

/*task sourcesJar(type: Jar, dependsOn: classes) {
	if(project in leafProjects) {
		classifier = "sources"
		archiveName = "${project.jarFileName}-$classifier.$extension"
		from sourceSets.main.allSource
	}
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	if(project in leafProjects) {
		classifier = "javadoc"
		archiveName = "${project.jarFileName}-$classifier.$extension"
		from javadoc.destinationDir
	}
}

artifacts {
	archives jar
	archives sourcesJar
	archives javadocJar
}

// see http://central.sonatype.org/pages/gradle.html for details
uploadArchives {

	// prevent the execution for empty (not leaf) subprojects and tests packages
	if(project.path.contains("tests") || !(project in leafProjects)) {
		return
	}

	LinkedList nameParts = new LinkedList()
	collectName(project, nameParts)

	def ossrhUsername = project.hasProperty("ossrhUsername") ?
		project.property("ossrhUsername") : null
	def ossrhPassword = project.hasProperty("ossrhPassword") ?
		project.property("ossrhPassword") : null

	repositories {
		mavenDeployer {
			beforeDeployment {
				MavenDeployment deployment -> signing.signPom(deployment)
			}

			repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
				authentication(userName: ossrhUsername, password: ossrhPassword)
			}

			snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
				authentication(userName: ossrhUsername, password: ossrhPassword)
			}

			pom {

				groupId = rootProject.group
				name = nameParts.join("-")
				artifactId = name

				project {
					description = rootProject.description

					url "https://github.com/emc-mongoose/mongoose/wiki"

					scm {
						connection "https://github.com/emc-mongoose/mongoose.git"
						developerConnection "https://github.com/emc-mongoose/mongoose.git"
						url "https://github.com/emc-mongoose/mongoose.git"
					}

					licenses {
						license {
							name "The MIT License (MIT)"
							url "https://github.com/emc-mongoose/mongoose/wiki/License"
						}
					}

					developers {
						developer {
							id "akurilov"
							name "Andrey Kurilov"
							email "akurilov123@gmail.com"
						}
					}
				}
			}
		}
	}
}*/
