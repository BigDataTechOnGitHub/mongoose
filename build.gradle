import groovy.json.JsonSlurper
import groovy.json.JsonParserType

import java.nio.file.Paths
import java.util.regex.Pattern
description = "Mongoose is a high-load storage performance testing tool"

buildscript {
	dependencies {
		classpath "com.google.gradle:osdetector-gradle-plugin:1.4.0"
	}
	repositories {
		mavenCentral()
	}
}

allprojects {

	repositories {
		mavenCentral()
	}

	apply plugin: "java"
	apply plugin: "maven"
	apply plugin: "signing"

	group = "com.github.emc-mongoose"
	version = defineVersion()

	signing {
		required {
			gradle.taskGraph.hasTask("uploadArchives")
		}
		sign configurations.archives
	}

	// travis deploy stage runs "./gradlew check" again which is unnecessary
	check.dependsOn -= test
}

String defineVersion() {
	def configFilePath = [rootDir, "config", "defaults.json"].join(File.separator);
	def inputFile = new File(configFilePath)
	def json = new JsonSlurper().setType(JsonParserType.LAX).parseText(inputFile.text)
	json.version
}

task printVersion {
	group = "versioning"
	description = "Prints Mongoose version."
	doLast { logger.quiet "Mongoose version: $version" }
}

ext {

	isExt = false
	jarFileName = rootProject.name
	javaHome = System.properties["java.home"]
	jreOutDir = "${rootProject.buildDir}${File.separator}jre"
	rootPkg = "com.emc.mongoose"
	optDepsDir = "${rootProject.buildDir}${File.separator}optDeps"

	depVersion = [
		commonsCodec : "1.11",
		commonsLang : "2.6",
		disruptor : "3.4.1",
		jackson : "2.9.5",
		javaCommons : "[2.0.0,)",
		javaConcurrent : "[2.0.0,)",
		javassist : "3.22.0-GA",
		slf4j : "1.7.25",
		log4j : "2.8.2",
		metrics : "4.0.2",
		nagaina : "[3.6.10,)",
		netty : "4.1.23.Final",
		nettyConnectionPool : "[1.0.0,)",
	]

	leafProjects = subprojects.findAll {
		it != project("api") && it != project("load") && it != project("storage") &&
			it != project("storage:driver")// && it != project("tests")
	}
}

configurations {
	moduleOpt
}

dependencies {
	moduleOpt(group: "avalon-framework", name: "avalon-framework", version: "4.1.5") { transitive = false }
	moduleOpt(group: "ch.qos.cal10n", name: "cal10n-api", version: "0.8.1") { transitive = false }
	moduleOpt(group: "com.beust", name: "jcommander", version: "1.72") { transitive = false }
	moduleOpt(group: "com.fasterxml.jackson.dataformat", name: "jackson-dataformat-xml", version: "${depVersion.jackson}") { transitive = false }
	moduleOpt(group: "com.fasterxml.jackson.dataformat", name: "jackson-dataformat-yaml", version: "${depVersion.jackson}") { transitive = false }
	moduleOpt(group: "com.fasterxml.jackson.module", name: "jackson-module-jaxb-annotations", version: "${depVersion.jackson}") { transitive = false }
	moduleOpt(group: "com.github.jponge", name: "lzma-java", version: "1.3") { transitive = false }
	moduleOpt(group: "com.github.luben", name: "zstd-jni", version: "1.3.4-2") { transitive = false }
	moduleOpt(group: "com.google.protobuf", name: "protobuf-java", version: "3.5.1") { transitive = false }
	moduleOpt(group: "com.google.protobuf", name: "protobuf-java", version: "3.5.1") { transitive = false }
	moduleOpt(group: "com.google.protobuf.nano", name: "protobuf-javanano", version: "3.1.0") { transitive = false }
	moduleOpt(group: "com.jcraft", name: "jzlib", version: "1.1.3") { transitive = false }
	moduleOpt(group: "commons-logging", name: "commons-logging", version: "1.2") { transitive = false }
	moduleOpt(group: "com.ning", name: "compress-lzf", version: "1.0.4") { transitive = false }
	moduleOpt(group: "com.sun.mail", name: "javax.mail", version: "1.6.1") { transitive = false }
	moduleOpt(group: "io.netty", name: "netty-tcnative", version: "2.0.8.Final") { transitive = false }
	moduleOpt(group: "javax.servlet", name: "javax.servlet-api", version: "4.0.0") { transitive = false }
	moduleOpt(group: "log4j", name: "log4j", version: "1.2.17") { transitive = false }
	moduleOpt(group: "logkit", name: "logkit", version: "2.0") { transitive = false }
	moduleOpt(group: "net.jpountz.lz4", name: "lz4", version: "1.3.0") { transitive = false }
	moduleOpt(group: "org.apache.commons", name: "commons-compress", version: "1.16.1") { transitive = false }
	moduleOpt(group: "org.apache.commons", name: "commons-csv", version: "1.5") { transitive = false }
	moduleOpt(group: "org.apache.kafka", name: "kafka-clients", version: "1.1.0") { transitive = false }
	moduleOpt(group: "org.bouncycastle", name: "bcpkix-jdk15on", version: "1.59") { transitive = false }
	moduleOpt(group: "org.bouncycastle", name: "bcprov-jdk15on", version: "1.59") { transitive = false }
	moduleOpt(group: "org.brotli", name: "dec", version: "0.1.2") { transitive = false }
	moduleOpt(group: "org.codehaus.woodstox", name: "stax2-api", version: "4.1") { transitive = false }
	moduleOpt(group: "org.conscrypt", name: "conscrypt-openjdk-uber", version: "1.1.0") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty.alpn", name: "alpn-api", version: "1.1.3.v20160715") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-alpn-client", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-alpn-server", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-http", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-io", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-jmx", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-npn-server", version: "9.3.0.M1") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-server", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty", name: "jetty-util", version: "9.4.9.v20180320") { transitive = false }
	moduleOpt(group: "org.eclipse.jetty.npn", name: "npn-api", version: "8.1.2.v20120308") { transitive = false }
	moduleOpt(group: "org.eclipse.persistence", name: "javax.persistence", version: "2.2.0") { transitive = false }
	moduleOpt(group: "org.fusesource.jansi", name: "jansi", version: "1.17") { transitive = false }
	moduleOpt(group: "org.jboss.marshalling", name: "jboss-marshalling", version: "2.0.5.Final") { transitive = false }
	moduleOpt(group: "org.jboss.modules", name: "jboss-modules", version: "1.8.1.Final") { transitive = false }
	moduleOpt(group: "org.jboss.spec.javax.jms", name: "jboss-jms-api_1.1_spec", version: "1.0.1.Final") { transitive = false }
	moduleOpt(group: "org.jctools", name: "jctools-core", version: "2.1.2") { transitive = false }
	moduleOpt(group: "org.osgi", name: "org.osgi.core", version: "6.0.0") { transitive = false }
	moduleOpt(group: "org.slf4j", name: "slf4j-ext", version: "${depVersion.slf4j}") { transitive = false }
	moduleOpt(group: "org.tukaani", name: "xz", version: "1.8") { transitive = false }
	moduleOpt(group: "org.yaml", name: "snakeyaml", version: "1.20") { transitive = false }
	moduleOpt(group: "org.zeromq", name: "jeromq", version: "0.4.3") { transitive = false }
	moduleOpt(group: "org.zeromq", name: "jnacl", version: "0.1.0") { transitive = false }
}

def classPathString(final configuration, final isExt) {
	return configuration
		.collect {
			file ->
				if(isExt) {
					// it's 3rd party if jar file name doesn't contain the root project name
					if(-1 == file.name.indexOf(rootProject.name)) {
						["..", "lib", file.name].join(File.separator)
					} else {
						["..", file.name].join(File.separator)
					}
				} else {
					// it's 3rd party if jar file name doesn't contain the root project name
					if(-1 == file.name.indexOf(rootProject.name)) {
						["lib", file.name].join(File.separator)
					} else {
						file.name
					}
				}
		}
		.join(" ")
}

void collectName(Project p, LinkedList<String> names) {
	names.addFirst p.name
	if(p.parent != null) {
		collectName(p.parent, names)
	}
}

subprojects {

	afterEvaluate {

		compileJava {
			if(project in leafProjects) {
				sourceCompatibility = JavaVersion.VERSION_1_10
				targetCompatibility = JavaVersion.VERSION_1_10
				inputs.property("moduleName", moduleName)
				doFirst {
					options.compilerArgs = [
						"--module-path", classpath.asPath,
					]
					classpath = files()
				}
			}
		}

		compileTestJava {
			if(project in leafProjects) {
				sourceCompatibility = JavaVersion.VERSION_1_10
				targetCompatibility = JavaVersion.VERSION_1_10
				inputs.property("moduleName", moduleName)
				doFirst {
					options.compilerArgs = [
						"--module-path", classpath.asPath,
						"--add-modules", "junit",
						"--add-reads", "${moduleName}.test=junit",
						"--patch-module", "${moduleName}=" + files(sourceSets.test.java.srcDirs).asPath,
					]
					classpath = files()
				}
			}
		}

		jar {
			if(project in leafProjects) {
				archiveName "${project.jarFileName}.${extension}"
				inputs.property("moduleName", moduleName)
				manifest {
					attributes(
						"Automatic-Module-Name": moduleName,
						"Class-Path": classPathString(configurations.runtime, project.isExt),
						"Implementation-Version": version,
						"Implementation-Title": "$name",
					)
				}
				if(null != project.mainClass) {
					manifest {
						attributes(
							"Main-Class": project.mainClass,
						)
					}
				}
			}
		}

		test {
			if(project in leafProjects) {
				inputs.property("moduleName", moduleName)
				doFirst {
					jvmArgs = [
						//"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005",
						"-XX:+HeapDumpOnOutOfMemoryError",
						"--module-path", classpath.asPath,
						'--add-exports', "${moduleName}/${moduleName}.test=junit",
						"--add-modules", "ALL-MODULE-PATH",
						"--add-reads", "${moduleName}.test=junit",
						"--patch-module", "${moduleName}=" + files(sourceSets.test.java.outputDir).asPath,
					]
					classpath = files()
				}
				maxHeapSize "1g"
				/*
				systemProperty "com.sun.management.jmxremote", "true"
				systemProperty "com.sun.management.jmxremote.port", "9010"
				systemProperty "com.sun.management.jmxremote.rmi.port", "9010"
				systemProperty "com.sun.management.jmxremote.local.only", "false"
				systemProperty "com.sun.management.jmxremote.authenticate", "false"
				systemProperty "com.sun.management.jmxremote.ssl", "false"
				*/
				testLogging {
					events "passed", "skipped", "failed", "standardOut"
					showExceptions = true
					showStandardStreams = true
				}
			}
		}
	}

	task sourcesJar(type: Jar, dependsOn: classes) {
		if(project in leafProjects) {
			classifier = "sources"
			archiveName "${project.jarFileName}-$classifier.$extension"
			from sourceSets.main.allSource
		}
	}

	task javadocJar(type: Jar, dependsOn: javadoc) {
		if(project in leafProjects) {
			classifier = "javadoc"
			archiveName "${project.jarFileName}-$classifier.$extension"
			from javadoc.destinationDir
		}
	}

	artifacts {
		archives jar
		archives sourcesJar
		archives javadocJar
	}

	// see http://central.sonatype.org/pages/gradle.html for details
	uploadArchives {

		// prevent the execution for empty (not leaf) subprojects and tests packages
		if(project.path.contains("tests") || !(project in leafProjects)) {
			return
		}

		LinkedList nameParts = new LinkedList()
		collectName(project, nameParts)

		def ossrhUsername = project.hasProperty("ossrhUsername") ?
			project.property("ossrhUsername") : null
		def ossrhPassword = project.hasProperty("ossrhPassword") ?
			project.property("ossrhPassword") : null

		repositories {
			mavenDeployer {
				beforeDeployment {
					MavenDeployment deployment -> signing.signPom(deployment)
				}

				repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
					authentication(userName: ossrhUsername, password: ossrhPassword)
				}

				snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
					authentication(userName: ossrhUsername, password: ossrhPassword)
				}

				pom {

					groupId = rootProject.group
					name = nameParts.join("-")
					artifactId = name

					project {
						description = rootProject.description

						url "https://github.com/emc-mongoose/mongoose/wiki"

						scm {
							connection "https://github.com/emc-mongoose/mongoose.git"
							developerConnection "https://github.com/emc-mongoose/mongoose.git"
							url "https://github.com/emc-mongoose/mongoose.git"
						}

						licenses {
							license {
								name "The MIT License (MIT)"
								url "https://github.com/emc-mongoose/mongoose/wiki/License"
							}
						}

						developers {
							developer {
								id "akurilov"
								name "Andrey Kurilov"
								email "akurilov123@gmail.com"
							}
						}
					}
				}
			}
		}
	}
}

task wrapper(type: Wrapper) {
	gradleVersion = "4.6"
}

static def isExtProject(final Project p) {
	final moduleInfoJavaFile = Paths
		.get(p.projectDir.toString(), "src", "main", "java", "module-info.java")
		.toFile()
	if(moduleInfoJavaFile.exists()) {
		return 0 < moduleInfoJavaFile
			.readLines()
			.findAll { line -> line =~ /\s+provides\s+[\w\\.]+/ }
			.size()
	} else {
		return false
	}
}

static def isTestsProject(final Project p) {
	if(p == null) {
		return false
	} else if(p.name.contains("test")) {
		return true
	} else {
		return isTestsProject(p.parent)
	}
}

task collectOptDeps(type: Copy) {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	excludes = [
		"**/*.css",
		"**/*.dll",
		"**/*.h",
		"**/*.html",
		"**/*.java",
		"**/pom.properties",
		"**/pom.xml",
		"aix/**",
		"darwin/**",
		"include/**",
		"jdk-module-paths/**",
		"kafka/**",
		"module-info.class",
		"schema/**",
		"win/**",
		"win32/**",
		"META-INF/*.DSA",
		"META-INF/*.RSA",
		"META-INF/*.SF",
		"META-INF/*.LIST",
		"META-INF/versions/**",
		"OSGI-OPT/**",
	]
	into optDepsDir
	configurations.moduleOpt.each {
		from zipTree(it.path)
	}
}

task mainJar(type: Jar, dependsOn: collectOptDeps) {

	leafProjects.each {
		dependsOn("${it.path}:compileJava")
	}

	archiveName = "${baseName}.${extension}"
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	excludes = [
		"module-info.class",
		"**/*.html",
		"META-INF/*.DSA",
		"META-INF/*.RSA",
		"META-INF/*.SF",
		"META-INF/*.LIST",
		"org/apache/commons/lang/enum/**"
	]
	manifest {
		attributes "Automatic-Module-Name": "${rootPkg}"
		attributes "Implementation-Title": rootProject.name
		attributes "Implementation-Version": version
	}

	// project classes and resources
	leafProjects
		.findAll {
			!isExtProject(it) && !isTestsProject(it)
		}
		.each {
			from it.compileJava.outputs.files
			from it.sourceSets.main.resources
		}

	// dependencies
	doFirst {
		final extRuntimeDeps = new HashSet<>()
		leafProjects
			.findAll {
				!isTestsProject(it)
			}
		.each {
			it.configurations.runtime
				.findAll {
					!it.name.startsWith(rootProject.name)
				}
				.each {
					extRuntimeDeps.add(it)
				}
		}
		extRuntimeDeps.each {
			from zipTree(it.path)
		}
	}

	// optional dependencies
	from optDepsDir
}

task genMainModuleInfo(type: Exec, dependsOn: mainJar) {
	executable = "${javaHome}${File.separator}bin${File.separator}jdeps"
	args = [
		"--module-path", "${javaHome}${File.separator}jmods",
		"--generate-module-info", "${rootProject.buildDir}",
		mainJar.outputs.files.iterator().next().path,
	]
}

task compileMainModuleInfo(type: Exec, dependsOn: genMainModuleInfo) {
	executable = "${javaHome}${File.separator}bin${File.separator}javac"
	args = [
		"--patch-module",
		"${rootPkg}=${mainJar.outputs.files.iterator().next().path}",
		"${rootProject.buildDir}${File.separator}${rootPkg}${File.separator}module-info.java",
		"-d", "${rootProject.buildDir}${File.separator}${rootPkg}"
	]
}

task mainModule(type: Exec, dependsOn: compileMainModuleInfo) {
	executable = "${javaHome}${File.separator}bin${File.separator}jar"
	workingDir = "${rootProject.buildDir}${File.separator}${rootPkg}"
	args = [
		"-uf",
		mainJar.outputs.files.iterator().next(),
		"module-info.class",
	]
}

task buildJre(type: Exec, dependsOn: mainModule) {
	executable = "${javaHome}${File.separator}bin${File.separator}jlink"
	args = [
		"--module-path",
		"${javaHome}${File.separator}jmods:${mainJar.outputs.files.iterator().next()}",
		"--add-modules", rootPkg,
		"--output", jreOutDir,
		"--compress=2",
		"--no-header-files",
		"--no-man-pages",
		"--strip-debug",
	]
}

task dist(type: Tar, dependsOn: buildJre) {
	group = "distribution"
	description = "Collect Mongoose as an archive"
	baseName = "$rootProject.name-base"
	compression = Compression.GZIP
	destinationDir = new File("build", "dist")
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	into("$rootProject.name-$rootProject.version") {
		into("config") {
			from { "config" }
		}
		into("example") {
			from { "example" }
		}
		final extProjects = leafProjects.findAll { isExtProject(it) }
		final nonExtNonTestProjects = leafProjects.findAll {
			!isExtProject(it) && !isTestsProject(it)
		}
		into("ext") {
			for(final Project p: extProjects) {
				from p.jar.outputs.files
			}
		}
		into("jre") {
			from jreOutDir
		}
		into("lib") {
			for(final Project p: leafProjects) {
				from p.configurations.runtime {
					exclude "${rootProject.name}*.jar"
				}
			}
		}
		for(final Project p: nonExtNonTestProjects) {
			from p.jar.outputs.files
		}
	}
}
