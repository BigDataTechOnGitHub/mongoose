package com.emc.mongoose.load.step.type.weighted;

import com.emc.mongoose.env.Extension;
import com.emc.mongoose.exception.OmgShootMyFootException;
import com.emc.mongoose.data.DataInput;
import com.emc.mongoose.item.io.IoType;
import com.emc.mongoose.item.Item;
import com.emc.mongoose.item.ItemFactory;
import com.emc.mongoose.item.ItemInfoFileOutput;
import com.emc.mongoose.item.ItemType;
import com.emc.mongoose.load.step.type.LoadController;
import com.emc.mongoose.load.generator.LoadGenerator;
import com.emc.mongoose.storage.driver.StorageDriver;
import com.emc.mongoose.load.step.type.BasicLoadController;
import com.emc.mongoose.load.generator.BasicLoadGeneratorBuilder;
import com.emc.mongoose.load.step.type.LoadStepBase;
import com.emc.mongoose.logging.LogUtil;
import com.emc.mongoose.logging.Loggers;

import com.github.akurilov.commons.io.Output;
import com.github.akurilov.commons.system.SizeInBytes;
import com.github.akurilov.commons.concurrent.throttle.IndexThrottle;
import com.github.akurilov.commons.concurrent.throttle.RateThrottle;
import com.github.akurilov.commons.concurrent.throttle.SequentialWeightsThrottle;
import static com.github.akurilov.commons.collection.TreeUtil.reduceForest;

import static com.github.akurilov.confuse.Config.ROOT_PATH;
import static com.github.akurilov.confuse.Config.deepToMap;

import com.github.akurilov.confuse.Config;
import com.github.akurilov.confuse.impl.BasicConfig;

import org.apache.logging.log4j.Level;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CancellationException;

public class WeightedLoadStep
extends LoadStepBase {

	public static final String TYPE = "WeightedLoad";

	public WeightedLoadStep(
		final Config baseConfig, final List<Extension> extensions,
		final List<Map<String, Object>> overrides
	) {
		super(baseConfig, extensions, overrides);
	}

	@Override
	public String getTypeName() {
		return TYPE;
	}

	@Override
	protected WeightedLoadStep copyInstance(final List<Map<String, Object>> stepConfigs) {
		return new WeightedLoadStep(baseConfig, extensions, stepConfigs);
	}

	@Override
	protected void init() {

		final String autoStepId = "weighted_" + LogUtil.getDateTimeStamp();
		final Config config = new BasicConfig(baseConfig);
		final Config stepConfig = config.configVal("load-step");
		if(stepConfig.boolVal("idAutoGenerated")) {
			stepConfig.val("id", autoStepId);
		}
		actualConfig(config);

		final int subStepCount = stepConfigs.size();

		// 1st pass: determine the weights map
		final int[] weights = new int[subStepCount];
		final List<Config> subConfigs = new ArrayList<>(subStepCount);
		for(int i = 0; i < subStepCount; i ++) {
			final Map<String, Object> mergedConfigTree = reduceForest(
				Arrays.asList(deepToMap(config), stepConfigs.get(subStepCount))
			);
			final Config subConfig = new BasicConfig(
				config.pathSep(), config.schema(), mergedConfigTree
			);
			subConfigs.add(subConfig);
			final int weight = subConfig.intVal("load-generator-weight");
			weights[i] = weight;
		}

		final IndexThrottle weightThrottle = new SequentialWeightsThrottle(weights);

		// 2nd pass: initialize the sub steps
		for(int originIndex = 0; originIndex < subStepCount; originIndex ++) {

			final Config subConfig = subConfigs.get(originIndex);
			final Config loadConfig = subConfig.configVal("load");
			final IoType ioType = IoType.valueOf(loadConfig.stringVal("type").toUpperCase());
			final int concurrency = loadConfig.intVal("step-limit-concurrency");
			final Config outputConfig = subConfig.configVal("output");
			final Config metricsConfig = outputConfig.configVal("metrics");
			final SizeInBytes itemDataSize = new SizeInBytes(subConfig.stringVal("item-data-size"));

			if(distributedFlag) {
				initDistributedMetrics(
					originIndex, ioType, concurrency, stepConfig.listVal("node-addrs").size(),
					metricsConfig, itemDataSize, outputConfig.boolVal("color")
				);
			} else {

				initLocalMetrics(
					ioType, concurrency, metricsConfig, itemDataSize, outputConfig.boolVal("color")
				);

				final Config itemConfig = subConfig.configVal("item");
				final Config storageConfig = subConfig.configVal("storage");
				final Config dataConfig = itemConfig.configVal("data");
				final Config dataInputConfig = dataConfig.configVal("input");
				final Config limitConfig = stepConfig.configVal("limit");
				final Config dataLayerConfig = dataInputConfig.configVal("layer");

				final String testStepId = stepConfig.stringVal("id");

				try {

					final DataInput dataInput = DataInput.instance(
						dataInputConfig.stringVal("file"), dataInputConfig.stringVal("seed"),
						new SizeInBytes(dataLayerConfig.stringVal("size")),
						dataLayerConfig.intVal("cache")
					);

					try {

						final StorageDriver driver = StorageDriver.instance(
							extensions, loadConfig, storageConfig, dataInput,
							dataConfig.boolVal("verify"), testStepId
						);
						drivers.add(driver);

						final ItemType itemType = ItemType.valueOf(
							itemConfig.stringVal("type").toUpperCase()
						);
						final ItemFactory<Item> itemFactory = ItemType.getItemFactory(itemType);
						final double rateLimit = loadConfig.doubleVal("step-limit-rate");

						try {
							final LoadGenerator generator = new BasicLoadGeneratorBuilder<>()
								.itemConfig(itemConfig)
								.loadConfig(loadConfig)
								.limitConfig(limitConfig)
								.itemType(itemType)
								.itemFactory((ItemFactory) itemFactory)
								.storageDriver(driver)
								.authConfig(storageConfig.configVal("auth"))
								.originIndex(originIndex)
								.rateThrottle(rateLimit > 0 ? new RateThrottle(rateLimit) : null)
								.weightThrottle(weightThrottle)
								.build();
							generators.add(generator);

							final LoadController controller = new BasicLoadController<>(
								testStepId, generator, driver, metricsContexts.get(originIndex),
								limitConfig,
								outputConfig.boolVal("metrics-trace-persist"),
								loadConfig.intVal("batch-size"),
								loadConfig.intVal("generator-recycle-limit")
							);
							controllers.add(controller);

							final String itemOutputFile = itemConfig.stringVal("output-file");
							if(itemOutputFile != null && itemOutputFile.length() > 0) {
								final Path itemOutputPath = Paths.get(itemOutputFile);
								if(Files.exists(itemOutputPath)) {
									Loggers.ERR.warn(
										"Items output file \"{}\" already exists", itemOutputPath
									);
								}
								try {
									final Output<? extends Item>
										itemOutput = new ItemInfoFileOutput<>(itemOutputPath);
									controller.ioResultsOutput(itemOutput);
								} catch(final IOException e) {
									LogUtil.exception(
										Level.ERROR, e,
										"Failed to initialize the item output, the processed " +
											"items info won't be persisted"
									);
								}
							}
						} catch(final OmgShootMyFootException e) {
							throw new IllegalStateException(
								"Failed to initialize the load generator", e
							);
						}
					} catch(final OmgShootMyFootException e) {
						throw new IllegalStateException(
							"Failed to initialize the storage driver", e
						);
					} catch(final InterruptedException e) {
						throw new CancellationException();
					}
				} catch(final IOException e) {
					throw new IllegalStateException("Failed to initialize the data input", e);
				}
			}
		}
	}
}
