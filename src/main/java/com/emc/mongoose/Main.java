package com.emc.mongoose;

import com.emc.mongoose.config.CliArgUtil;
import com.emc.mongoose.config.AliasingUtil;
import com.emc.mongoose.config.IllegalArgumentNameException;
import com.emc.mongoose.config.ConfigUtil;
import com.emc.mongoose.logging.LogUtil;
import com.emc.mongoose.logging.Loggers;
import com.emc.mongoose.model.env.Extensions;
import static com.emc.mongoose.scenario.step.Constants.ATTR_CONFIG;
import static com.emc.mongoose.Constants.APP_NAME;
import static com.emc.mongoose.Constants.DIR_EXAMPLE_SCENARIO;
import static com.emc.mongoose.Constants.KEY_CLASS_NAME;
import static com.emc.mongoose.Constants.KEY_STEP_ID;
import static com.emc.mongoose.Constants.PATH_DEFAULTS;
import static com.emc.mongoose.config.CliArgUtil.allCliArgs;
import com.emc.mongoose.model.svc.Service;
import com.emc.mongoose.scenario.step.ScriptEngineUtil;
import com.emc.mongoose.scenario.step.node.BasicFileManagerService;
import com.emc.mongoose.scenario.step.node.BasicLoadStepManagerService;

import com.github.akurilov.confuse.Config;
import com.github.akurilov.confuse.SchemaProvider;
import com.github.akurilov.confuse.exceptions.InvalidValuePathException;
import com.github.akurilov.confuse.exceptions.InvalidValueTypeException;

import org.apache.logging.log4j.CloseableThreadContext;
import static org.apache.logging.log4j.CloseableThreadContext.Instance;
import org.apache.logging.log4j.Level;

import static javax.script.ScriptContext.ENGINE_SCOPE;
import javax.script.ScriptEngine;
import javax.script.ScriptException;
import java.io.File;
import java.io.IOException;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public final class Main {

	public static void main(final String... args) {

		final InstallHook installHook = new InstallHook();
		final Path appHomePath = installHook.appHomePath();
		final String initialStepId = "none-" + LogUtil.getDateTimeStamp();

		try(
			final Instance logCtx = CloseableThreadContext
				.put(KEY_STEP_ID, initialStepId)
				.put(KEY_CLASS_NAME, Main.class.getSimpleName())
		) {

			LogUtil.init(appHomePath.toString());
			installHook.run();

			try(final URLClassLoader extClsLoader = Extensions.extClassLoader(appHomePath)) {

				// load the initial config from the file
				final File defaultsFile = Paths.get(appHomePath.toString(), PATH_DEFAULTS).toFile();
				final Map<String, Object> configSchema;
				final Config config;
				try {
					configSchema = SchemaProvider.resolveAndReduce(APP_NAME, extClsLoader);
					config = ConfigUtil.loadConfig(defaultsFile, configSchema);
				} catch(final Exception e) {
					LogUtil.exception(
						Level.ERROR, e, "Failed to load the defaults from {}", defaultsFile
					);
					return;
				}

				// parse the CLI args and apply them to the config instance
				try {
					final Map<String, String> parsedArgs = CliArgUtil.parseArgs(args);
					final List<Map<String, Object>> aliasingConfig = config.listVal("aliasing");
					final Map<String, String> aliasedArgs = AliasingUtil.apply(
						parsedArgs, aliasingConfig
					);
					aliasedArgs.forEach(config::val);
				} catch(final IllegalArgumentNameException e) {
					final String formattedAllCliArgs = allCliArgs(configSchema, config.pathSep())
						.stream()
						.collect(Collectors.joining("\n", "\t", ""));
					Loggers.ERR.fatal(
						"Invalid argument: \"{}\"\nThe list of all possible args:\n{}", e.getMessage(),
						formattedAllCliArgs
					);
					return;
				} catch(final InvalidValuePathException e) {
					Loggers.ERR.fatal("Invalid configuration option: \"{}\"", e.path());
					return;
				} catch(final InvalidValueTypeException e) {
					Loggers.ERR.fatal(
						"Invalid configuration value type for the option \"{}\", expected: {}, " +
							"actual: {}", e.path(), e.expectedType(), e.actualType()
					);
					return;
				}

				if(null == config.val("scenario-step-id")) {
					config.val("scenario-step-id", initialStepId);
					config.val("scenario-step-idAutoGenerated", true);
				}

				Arrays.stream(args).forEach(Loggers.CLI::info);
				Loggers.CONFIG.info(ConfigUtil.toString(config));
				if(config.boolVal("node")) {
					runNode(config, extClsLoader);
				} else {
					runScenario(config, extClsLoader, appHomePath);
				}

			} catch(final Exception e) {
				LogUtil.exception(Level.ERROR, e, "Unexpected failure");
			}
		}
	}

	private static void runNode(final Config config, final ClassLoader clsLoader) {
		final int listenPort = config.intVal("scenario-step-node-port");
		Service inputFileSvc = null;
		Service scenarioStepSvc = null;
		try {
			inputFileSvc = new BasicFileManagerService(listenPort);
			inputFileSvc.start();
			scenarioStepSvc = new BasicLoadStepManagerService(listenPort, clsLoader);
			scenarioStepSvc.start();
			scenarioStepSvc.await();
		} catch(final Throwable cause) {
			cause.printStackTrace(System.err);
		} finally {
			try {
				if(inputFileSvc != null) {
					inputFileSvc.close();
				}
				if(scenarioStepSvc != null) {
					scenarioStepSvc.close();
				}
			} catch(final IOException ignored) {
			}
		}
	}

	@SuppressWarnings("StringBufferWithoutInitialCapacity")
	private static void runScenario(
		final Config config, final ClassLoader clsLoader, final Path appHomePath
	) {
		// get the scenario file/path
		final Path scenarioPath;
		final Config scenarioConfig = config.configVal("scenario");
		final String scenarioFile = scenarioConfig.stringVal("file");
		if(scenarioFile != null && !scenarioFile.isEmpty()) {
			scenarioPath = Paths.get(scenarioFile);
		} else {
			scenarioPath = Paths.get(
				appHomePath.toString(), DIR_EXAMPLE_SCENARIO, "js", "default.js"
			);
		}

		final StringBuilder strb = new StringBuilder();
		try {
			Files
				.lines(scenarioPath)
				.forEach(line -> strb.append(line).append(System.lineSeparator()));
		} catch(final IOException e) {
			LogUtil.exception(
				Level.FATAL, e, "Failed to read the scenario file \"{}\"", scenarioPath
			);
		}
		final String scenarioText = strb.toString();
		Loggers.SCENARIO.log(Level.INFO, scenarioText);

		final ScriptEngine scriptEngine = ScriptEngineUtil.resolve(scenarioPath, clsLoader);
		if(scriptEngine == null) {
			Loggers.ERR.fatal(
				"Failed to resolve the scenario engine for the file \"{}\"", scenarioPath
			);
		} else {

			Loggers.MSG.info(
				"Using the \"{}\" scenario engine", scriptEngine.getFactory().getEngineName()
			);

			// expose the environment values
			System.getenv().forEach(scriptEngine::put);
			// expose the loaded configuration
			scriptEngine.getContext().setAttribute(ATTR_CONFIG, config, ENGINE_SCOPE);
			// expose the step types
			ScriptEngineUtil.registerStepTypes(scriptEngine, clsLoader, config);
			// go
			try {
				scriptEngine.eval(scenarioText);
			} catch(final ScriptException e) {
				LogUtil.exception(
					Level.ERROR, e,
					"\nScenario failed @ file \"{}\", line #{}, column #{}:\n{}",
					scenarioPath, e.getLineNumber(), e.getColumnNumber(), e.getMessage()
				);
			}
		}
	}
}
