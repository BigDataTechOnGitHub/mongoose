<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta charset="utf-8">
	<title>Mongoose Scenario Engine Design</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
<fieldset>
	<legend><h2>SCENARIO ENGINE</h2></legend>
	<p>
		<fieldset>
			<legend><h3>CONTENTS</h3></legend>
			<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#limitations">Limitations</a></li>
				<li>
					<a href="#approach">Approach</a>
					<ul>
						<li><a href="#run">Run a Scenario</a></li>
						<li>
							<a href="#syntax">Scenario File Syntax</a>
							<ul>
								<li><a href="#jobtypes">Job Types</a></li>
								<li><a href="#confignode">Configuration Node</a></li>
								<li><a href="#seqandparjobs">Sequential and Parallel Jobs</a></li>
								<li><a href="#command">Execute a Shell Command</a></li>
								<li><a href="#itemslists">Using Items Lists</a></li>
								<li><a href="#loops">Loops</a></li>
								<li><a href="#env">Parameterizing with Environment Variables</a></li>
							</ul>
						</li>
					</ul>
				</li>
				<li><a href="#config">Configuration</a></li>
				<li><a href="#reporting">Reporting</a></li>
			</ul>
		</fieldset>
	</p>
	<p>
		<fieldset id="introduction">
			<legend><h3>INTRODUCTION</h3></legend>
			<p>The performance testing software should be able to be scripted in order to execute
			complex tests ("weighted CRUD" or "maxtest", etc). The general way to describe the
			actions which should be performed in the test is the organizing them to the sequences
			and parallel sets. So does Apache JMeter, COSBench and other tools. It's decided to
			rework the way to configure Mongoose in order to make Mongoose more human-friendly and
			flexible.</p>
		</fieldset>
	</p>
	<p>
		<fieldset id="limitations">
			<legend><h3>LIMITATIONS</h3></legend>
			<p>
				<ul>
					<li>The scenario scripting feature available since v2.0.0</li>
					<li>"Command" job feature available since v2.2.0</li>
					<li>"For" job feature available since v2.3.0</li>
					<li>Scenario parametrization with environment variables feature available since v2.4.0</li>
				</ul>
			</p>
		</fieldset>
	</p>
	<p>
		<fieldset id="approach">
			<legend><h3>APPROACH</h3></legend>
			<p>
				<h4 id="run">Run a Scenario</h4>
				<p>
					There are two ways to feed the scenario to Mongoose:
					<ol>
						<li>
							Specify the file containing the scenario:
							<fieldset class="bash">
								java [&lt;DEFAULTS_OVERRIDING&gt;] -jar mongoose.jar [&lt;MODE&gt;] -f &lt;PATH/TO/SCENARIO.json&gt;
							</fieldset>
						</li>
						<li>
							Provide the scenario content on the standard input of mongoose (note the "-I" argument):
							<fieldset class="bash">
								cat &lt;PATH/TO/SCENARIO.json&gt; | java [&lt;DEFAULTS_OVERRIDING&gt;] -jar mongoose.jar [&lt;MODE&gt;] -I
							</fieldset>
							<fieldset class="info">
								Mongoose will await the scenario input from the user if there's
								nor scenario file specified neither scenario data on the standard
								input. Note the highlighted scenario data specified by user in this
								semi-interactive mode.
								<fieldset class="bash" style="color: #00ff00">
									<pre>2016-04-14T12:24:32,705 I ScenarioRunner       main                                     Using the s&#8617;
    cenario from the standard input
{
        "type" : "load",
        "config" : { "load" : { "limit" : { "time" : "1m" } } }
}
2016-04-14T12:25:04,982 I HttpBucketHelper     main                                     Bucket "mons&#8617;
    goose-2016.04.14.12.25.04.883" created
2016-04-14T12:25:05,028 I LoadExecutorBase     main                                     0-S3-Write-s&#8617;
    1x1: will use "newDataItemSrc&lt;BasicHttpData&gt;" as an item source
2016-04-14T12:25:05,163 I SingleJobContainer   main                                     Start the js&#8617;
    ob "0-S3-Write-1x1"
2016-04-14T12:25:05,194 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(0/0)s&#8617;
    ; duration[us]=(0/0/0); latency[us]=(0/0/0); TP[op/s]=(0.000/0.000); BW[MB/s]=(0.000/0.000)
2016-04-14T12:25:15,201 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(1654s&#8617;
    6/0); duration[us]=(442/370/1307); latency[us]=(136/47/916); TP[op/s]=(1827.394/1590.264); BW[M&#8617;
    B/s]=(1827.394/1590.249)
2016-04-14T12:25:25,201 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(3865s&#8617;
    0/0); duration[us]=(418/357/1283); latency[us]=(132/47/393); TP[op/s]=(2026.467/1981.767); BW[M&#8617;
    B/s]=(2026.467/1981.761)
2016-04-14T12:25:35,202 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(6068&#8617;
    1/0); duration[us]=(410/357/1245); latency[us]=(131/47/546); TP[op/s]=(2085.863/2121.699); BW[M&#8617;
    B/s]=(2085.863/2121.691)
2016-04-14T12:25:45,204 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(8233&#8617;
    8/0); duration[us]=(407/357/1394); latency[us]=(131/47/632); TP[op/s]=(2105.416/2146.232); BW[M&#8617;
    B/s]=(2105.416/2146.229)
2016-04-14T12:25:55,204 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(1040&#8617;
    74/0); duration[us]=(405/357/1245); latency[us]=(130/47/632); TP[op/s]=(2118.564/2159.117); BW[&#8617;
    MB/s]=(2118.585/2159.206)
2016-04-14T12:26:05,205 I LoadExecutorBase     0-S3-Write-1x1-metrics                   count=(1257&#8617;
    23/0); duration[us]=(405/357/1392); latency[us]=(130/47/632); TP[op/s]=(2125.672/2162.451); BW[&#8617;
    MB/s]=(2125.672/2162.426)
2016-04-14T12:26:05,258 I LoadExecutorBase     main                                     "0-S3-Writes&#8617;
    -1x1" summary: count=(127782/0); duration[us]=(404/357/390/395/403/1392); latency[us]=(130/50/1&#8617;
    22/130/137/632); TP[op/s]=(2126.772/2160.124); BW[MB/s]=(2126.772/2160.102)
2016-04-14T12:26:05,266 I JsonScenario         main                                     Scenario end</pre>
								</fieldset>
							</fieldset>
						</li>
					</ol>
				</p>
				<p>A custom scenario to run with mongoose should be in the JSON format.</p>
				<p>
					The only meaningful mode which may be used with a scenario is "client"
					("standalone" is used by default when mode is not specified at all). For
					example, in order to run the scenario in the distributed mode it's enough to
					add the client argument and the property overriding the default load server
					address list (which is 127.0.0.1 by default).
					<fieldset class="bash">
						<pre>java -Dload.server.addrs=192.168.0.3,192.168.0.4,192.168.0.5 -jar mongoose.jar client -f &lt;PATH/T&#8617;
	O/SCENARIO.json&gt;</pre>
					</fieldset>
				</p>
				<h4 id="syntax">Scenario File Syntax</h4>
				<h5 id="jobtypes">Job Types</h5>
				<p>
					Basically the scenario file describes the jobs hierarchy to execute.
					<ul>
						<li>The root scenario node is always a job:
							<fieldset class="json">
								<pre>
{
    "type" : <font color="blue">&lt;ROOT_JOB_TYPE&gt;</font>
    ...
}</pre>
							</fieldset>
						</li>
						<li>Jobs may include other (children) jobs:
							<fieldset class="json">
								<pre>
{
    "type" : <font color="blue">&lt;CONTAINER_JOB_TYPE&gt;</font>
    "jobs" : [
        {
            "type" : &lt;CHILD_JOB_TYPE&gt;
            ...
        }, {
            "type" : &lt;CHILD_JOB_TYPE&gt;
            ...
        }
    ]
}</pre>
							</fieldset>
						</li>
					</ul>
				</p>
				<p>The full list of the job types is described in the table below:</p>
				<table>
					<tr>
						<th>Job Type</th>
						<th>Description</th>
						<th>Nested Jobs</th>
						<th>Mandatory<br/>Attributes</th>
						<th>Optional<br/>Attributes</th>
					</tr>
					<tr>
						<td>load</td>
						<td>The single load job node.<br/></td>
						<td>Not Allowed</td>
						<td>
							<ul>
								<li>type</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>config</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>precondition&nbsp;&nbsp;&nbsp;&nbsp;</td>
						<td>
							Same as the "load", but the load job is executed in the "precondition" mode.
							In the precondition mode the metrics are not persisted into the output CSV files.
						</td>
						<td>Required</td>
						<td>
							<ul>
								<li>type</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>config</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>parallel</td>
						<td>The container job for the nested jobs which should be executed in parallel.</td>
						<td>Required</td>
						<td>
							<ul>
								<li>type</li>
								<li>jobs</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>config</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>sequential</td>
						<td>The container job for the nested jobs which should be executed sequentially.</td>
						<td>Required</td>
						<td>
							<ul>
								<li>type</li>
								<li>jobs</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>config</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>for</td>
						<td>
							The container job which executes the nested jobs for each value
							taken from the specified list and substituted into specified place
							of the configuration
						</td>
						<td>Required</td>
						<td>
							<ul>
								<li>type</li>
								<li>value</li>
								<li>in</li>
								<li>jobs</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>config</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>command</td>
						<td>
							The container executes the specified shell command.
							Also allows to start a command not blocking the scenario execution.
						</td>
						<td>Not Allowed</td>
						<td>
							<ul>
								<li>type</li>
								<li>value</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>blocking</li>
							</ul>
						</td>
					</tr>
				</table>
				<h5 id="confignode">Configuration Node</h5>
				<p>
					Any job type except "command" may contain an optional "config" node:
					<fieldset class="json">
						<pre>
    {
        "type" : <font color="blue">&lt;CONFIGURABLE_JOB_TYPE&gt;</font>
        <b>"config" : {</b>
            <font color="darkgreen">// here are the configuration hierarchy</font>
        <b>}</b>
    }</pre>
					</fieldset>
				</p>
				<p>
					<b><font color="darkred">Note</font></b> that the configuration is inherited by the
					nested load jobs and overrided by the child job's configuration
				</p>
				<p>
					The layout of the "config" subtree is the same as for default configuration.
					The configuration values override (see "Configuration Order" section):
					<ul>
						<li>Any default configuration values</li>
						<li>Any values passed by CLI</li>
						<li>A configuration from the parent job container</li>
					</ul>
				</p>
				<p>
					Let's realize that Mongoose is launched with the following command:
					<fieldset class="bash">
						java -Dstorage.addrs=A,B,C,D -jar mongoose.jar -f scenario/custom.json
					</fieldset>
				</p>
				<p>
					And the scenario file "custom.json" contains the following text:
					<fieldset class="json">
						<pre>
{
    "type" : "load"
    "config" : {
        "storage" : {
            "addrs" : [
                "E", "F", "G", "H"
            ]
        }
    }
}</pre>
					</fieldset>
				</p>
				<p>The effective storage address list will be "E,F,G,H" in this case.</p>
				<p>
					Another example demonstrates the <b>configuration inheritance</b>:
					<fieldset class="json">
						<pre>
{
    "type" : "sequential"
    "config" : {
        <b><font color="darkgreen">// the configuration will be inherited by nested jobs</font></b>
        "storage" : {
            "addrs" : [
                "E", "F", "G", "H"
            ]
        }
    },
    "jobs" : [
        {
            "type" : "load",
            "config" : {
                <b><font color="darkgreen">// will override the parent job's configuration</font></b>
                "storage" : {
                    "addrs" : [
                        "I", "J", "K"
                    ]
                }
            }
        }, {
            "type" : "load"
            <b><font color="darkgreen">// will inherit the parent job's configuration (storage addrs: E, F, G, H)</font></b>
        }
    ]
}</pre>
					</fieldset>
				</p>
				<p>
					The effective storage address list will be "I,J,K" for the 1st load job in the
					sequence and "E,F,G,H" in for the 2nd load job (configuration values inherited
					from the parent job).
				</p>
				<h5 id="seqandparjobs">Sequential and Parallel Jobs</h5>
				<p>
					Any job of the type "sequential" or "parallel" should include "jobs" element
					which behaves as the list of the children jobs.The configuration specified for a
					sequential/parallel job is inherited by the children jobs.
				</p>
				<h5 id="command">Execute a Shell Command</h5>
				<p>
					It may be useful to insert a sleep node into the jobs list between the actual load jobs:
					<fieldset class="json">
						<pre>
{
    "type" : "sequential"
    "config" : {
        <font color="darkgreen">// shared configuration values inherited by the children jobs</font>
    },
    "jobs" : [
        {
            "type" : "load",
            "config" : {
                <font color="darkgreen">// specific configuration for the 1st load job</font>
            }
        }, {
            <b>"type" : "command",
            "value" : "sleep 5m"</b>
        }, {
            "type" : "load",
            "config" : {
                <font color="darkgreen">// specific configuration for the 2nd load job</font>
            }
        }
    ]
}</pre>
					</fieldset>
				</p>
				<h5 id="itemslists">Using Items Lists</h5>
				<p>
					In the real world the output of a load job should be used by another load
					job. For example, "create" load job should output the file containing the items
					have been created. And this list should be used for "read" load job as an input.
				</p>
				<p>
					The example scenario below consist of 3 sequential steps:
					<ol>
						<li>(Preconditon) Create some items. Save the created items info into the destination file "/tmp/items2read.csv".</li>
						<li>Read the items specified by the list file "/tmp/items2read.csv". Save the read items info into the destination file "/tmp/items2delete.csv".</li>
						<li>Delete the items specified by the list file "/tmp/items2delete.csv". The default items destination will be used (log file).</li>
					</ol>
				</p>
				<p>
					<fieldset class="json">
						<pre>
{
    "type" : "sequential"
    "config" : {
        <i><font color="darkgreen">// shared configuration values inherited by the children jobs</font></i>
    },
    "jobs" : [
        {
            "type" : "precondition",
            "config" : {
                "item" : {
                    "dst" : {
                        <b>"file" : "/tmp/items2read.csv"</b>
                    }
                }
        }, {
            "type" : "load",
            "config" : {
                "item" : {
                    "src" : {
                        <b>"file" : "/tmp/items2read.csv"</b>
                    },
                    "dst" : {
                        <b>"file" : "/tmp/items2delete.csv"</b>
                    }
                },
                "load" : {
                    "type" : "read"
                }
            }
        }, {
            "type" : "load",
            "config" : {
                "item" : {
                    "src" : {
                        <b>"file" : "/tmp/items2delete.csv"</b>
                    }
                },
                "load" : {
                    "type" : "delete"
                }
            }
        }
    ]
}</pre>
					</fieldset>
				</p>
				<h5 id="loops">Loops</h5>
				<p>
					The "for" job performs the recurrent execution of the children jobs.
					The exact behavior depends on the "in" and "value" attributes values.
					<table>
						<tr>
							<th>in</th>
							<th>value</th>
							<th>Resulting effect</th>
						</tr>
						<tr>
							<td>Not set</td>
							<td>Not set</td>
							<td>Infinite loop</td>
						</tr>
						<tr>
							<td>Not set</td>
							<td>Integer &gt;0</td>
							<td>Counter based loop</td>
						</tr>
						<tr>
							<td>String identifier&nbsp;&nbsp;</td>
							<td>Value list or the <i>range</i>&nbsp;&nbsp;</td>
							<td>
								"for each" based loop
							</td>
						</tr>
					</table>
				</p>
				<p>
					The last case ("for each") also is capable to perform the value substitution
					in its configuration or in the configuration of the children jobs:
					<fieldset class="json">
						<pre>
{
   "type" : <b>"for"</b>,
   "value" : "<font color="blue">threads</font>",
   "in" : [
      <font color="darkviolet">1, 10, 100, 1000, 10000, 100000</font>
   ],
   "config" : {
      "load" : {
         "threads" : "<font color="darkcyan">${</font><font color="blue">threads</font><font color="darkcyan">}</font>"
      }
   },
   "jobs" : [
      {
            "type" : "load"
      }
   ]
}</pre>
					</fieldset>
				</p>
				<p>
					The example above will try to execute the load job 6 times. Each time the load
					job will be executed for the next thread count from the list specified
					(1, 10, 100, ...)
				</p>
				<p>
					The range syntax is also supported:
<fieldset class="json">
						<pre>
{
   "type" : <b>"for"</b>,
   "value" : "<font color="blue">threads</font>",
   "in" : <b><font color="darkviolet">"-2-7.5,0.5",</font></b>
   "config" : {
      "load" : {
         "threads" : "<font color="darkcyan">${</font><font color="blue">threads</font><font color="darkcyan">}</font>"
      }
   },
   "jobs" : [
      {
            "type" : "load"
      }
   ]
}</pre>
</fieldset>
				</p>
				<p>
					The example above is equivalent to the loop defined as (i = -2.0; i &lt; 7.5; i += 0.5)
				</p>
				<p>
					The exact range pattern is <b>X[-Y[,Z]]</b> where:
					<ul>
						<li>X is the start (1st) value, may be negative</li>
						<li>Y is the end value (exclusive), may be negative or/and less than start value</li>
						<li>Z is the step value, should always be a positive number</li>
					</ul>
					If start value is greater than end value the loop is defined as:
				</p>
				<p>
					(i = X; i &gt; Y; i -= Z)
				</p>
				<h5 id="env">Parameterizing with Environment Variables</h5>
				<p>
					It's possible to substitute a json values in the scenario with the
					environment variable values. This may help to keep the scenario file unchanged
					parameterizing the behavior from the command line only.
				</p>
				<p>
					Example scenario:
					<fieldset class="json">
						<pre>
{
    "type" : "load",
    "config" : {
        "item" : {
            "data" : {
                "size" : "${ITEM_DATA_SIZE}"
            },
            "dst" : {
                "container" : "${ITEM_DST_CONTAINER}"
            },
            "src" : {
                "file" : "${ITEM_SRC_FILE}"
            }
        },
        "load" : {
            "threads" : "${LOAD_THREADS}",
            "type" : "${LOAD_TYPE}"
        }
    }
}</pre>
					</fieldset>
				</p>
				<p>
					Example commands to run this scenario:
					<fieldset class="bash">
export ITEM_DST_CONTAINER=bucket1<br/>
export ITEM_SRC_FILE=<br/>
export LOAD_THREADS=100<br/>
export ITEM_DATA_SIZE=1KB<br/>
export LOAD_TYPE=create<br/>
java -jar mongoose.jar -f &ltPATH_TO_SCENARIO&gt;.json
					</fieldset>
				</p>
		</fieldset>
	</p>
	<p>
		<fieldset id="config">
			<legend><h3>CONFIGURATION</h3></legend>
			<p>
				Each next step means that the same configuration values from the previous step are
				overriden by the values from the current step:
				<ol>
					<li>Configuration loaded from defaults.json</li>
					<li>Configuration loaded from JVM arguments and environment properties</li>
					<li>Configuration from any parent job container</li>
					<li>Configuration from the current job container</li>
				</ol>
			</p>
		</fieldset>
	</p>
	<p>
		<fieldset id="reporting">
			<legend><h3>REPORTING</h3></legend>
			<p>
				Any "for" job logs the message for each value invocation with the following format:
				<fieldset class="log">
					&lt;TIMESTAMP&gt; I ForJob    main        Use next value for "&lt;ARG&gt;": &lt;VALUE&gt;
				</fieldset>
			</p>
		</fieldset>
	</p>
</fieldset>
</body>
</html>
